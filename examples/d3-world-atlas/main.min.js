var example = (function (exports) {
  'use strict';

  function resizeCanvasToDisplaySize(canvas, multiplier) {
    // Make sure the canvas drawingbuffer is the same size as the display
    // webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

    // multiplier allows scaling. Example: multiplier = window.devicePixelRatio
    if (!multiplier || multiplier < 0) multiplier = 1;

    const width = Math.floor(canvas.clientWidth * multiplier);
    const height = Math.floor(canvas.clientHeight * multiplier);

    // Exit if no change
    if (canvas.width === width && canvas.height === height) return false;

    // Resize drawingbuffer to match resized display
    canvas.width = width;
    canvas.height = height;
    return true;
  }

  // Adds floating point numbers with twice the normal precision.
  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
  // 305–363 (1997).
  // Code adapted from GeographicLib by Charles F. F. Karney,
  // http://geographiclib.sourceforge.net/

  function adder() {
    return new Adder;
  }

  function Adder() {
    this.reset();
  }

  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0; // exact error
    },
    add: function(y) {
      add(temp, y, this.t);
      add(this, temp.s, this.s);
      if (this.s) this.t += temp.t;
      else this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };

  var temp = new Adder;

  function add(adder, a, b) {
    var x = adder.s = a + b,
        bv = x - a,
        av = x - bv;
    adder.t = (a - av) + (b - bv);
  }

  var epsilon = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;

  var degrees = 180 / pi;
  var radians = pi / 180;

  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var ceil = Math.ceil;
  var sin = Math.sin;
  var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
  var sqrt = Math.sqrt;

  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
  }

  function asin(x) {
    return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
  }

  function noop() {}

  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }

  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };

  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };

  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }

  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }

  function geoStream(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  var areaRingSum = adder();

  var areaSum = adder();

  function spherical(cartesian) {
    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
  }

  function cartesian(spherical) {
    var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }

  function cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }

  // TODO return a
  function cartesianAddInPlace(a, b) {
    a[0] += b[0], a[1] += b[1], a[2] += b[2];
  }

  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }

  // TODO return d
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  var deltaSum = adder();

  function compose(a, b) {

    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }

    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };

    return compose;
  }

  function rotationIdentity(lambda, phi) {
    return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
  }

  rotationIdentity.invert = rotationIdentity;

  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
      : rotationLambda(deltaLambda))
      : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
      : rotationIdentity);
  }

  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
    };
  }

  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }

  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos(deltaPhi),
        sinDeltaPhi = sin(deltaPhi),
        cosDeltaGamma = cos(deltaGamma),
        sinDeltaGamma = sin(deltaGamma);

    function rotation(lambda, phi) {
      var cosPhi = cos(phi),
          x = cos(lambda) * cosPhi,
          y = sin(lambda) * cosPhi,
          z = sin(phi),
          k = z * cosDeltaPhi + x * sinDeltaPhi;
      return [
        atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
        asin(k * cosDeltaGamma + y * sinDeltaGamma)
      ];
    }

    rotation.invert = function(lambda, phi) {
      var cosPhi = cos(phi),
          x = cos(lambda) * cosPhi,
          y = sin(lambda) * cosPhi,
          z = sin(phi),
          k = z * cosDeltaGamma - y * sinDeltaGamma;
      return [
        atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
        asin(k * cosDeltaPhi - x * sinDeltaPhi)
      ];
    };

    return rotation;
  }

  // Generates a circle centered at [0°, 0°], with a given radius and precision.
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta) return;
    var cosRadius = cos(radius),
        sinRadius = sin(radius),
        step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
    }
    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
      point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
      stream.point(point[0], point[1]);
    }
  }

  // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
  function circleRadius(cosRadius, point) {
    point = cartesian(point), point[0] -= cosRadius;
    cartesianNormalizeInPlace(point);
    var radius = acos(-point[1]);
    return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
  }

  function clipBuffer() {
    var lines = [],
        line;
    return {
      point: function(x, y) {
        line.push([x, y]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  function pointEqual(a, b) {
    return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
  }

  function Intersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other; // another intersection
    this.e = entry; // is an entry?
    this.v = false; // visited
    this.n = this.p = null; // next & previous
  }

  // A generalized polygon clipping algorithm: given a polygon that has been cut
  // into its visible line segments, and rejoins the segments by interpolating
  // along the clip edge.
  function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
    var subject = [],
        clip = [],
        i,
        n;

    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n], x;

      // If the first and last points of a segment are coincident, then treat as a
      // closed ring. TODO if all rings are closed, then the winding order of the
      // exterior ring should be checked.
      if (pointEqual(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }

      subject.push(x = new Intersection(p0, segment, null, true));
      clip.push(x.o = new Intersection(p0, null, x, false));
      subject.push(x = new Intersection(p1, segment, null, false));
      clip.push(x.o = new Intersection(p1, null, x, true));
    });

    if (!subject.length) return;

    clip.sort(compareIntersection);
    link(subject);
    link(clip);

    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }

    var start = subject[0],
        points,
        point;

    while (1) {
      // Find first unvisited intersection.
      var current = start,
          isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }

  function link(array) {
    if (!(n = array.length)) return;
    var n,
        i = 0,
        a = array[0],
        b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }

  var sum = adder();

  function longitude(point) {
    if (abs(point[0]) <= pi)
      return point[0];
    else
      return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
  }

  function polygonContains(polygon, point) {
    var lambda = longitude(point),
        phi = point[1],
        sinPhi = sin(phi),
        normal = [sin(lambda), -cos(lambda), 0],
        angle = 0,
        winding = 0;

    sum.reset();

    if (sinPhi === 1) phi = halfPi + epsilon;
    else if (sinPhi === -1) phi = -halfPi - epsilon;

    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m = (ring = polygon[i]).length)) continue;
      var ring,
          m,
          point0 = ring[m - 1],
          lambda0 = longitude(point0),
          phi0 = point0[1] / 2 + quarterPi,
          sinPhi0 = sin(phi0),
          cosPhi0 = cos(phi0);

      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j],
            lambda1 = longitude(point1),
            phi1 = point1[1] / 2 + quarterPi,
            sinPhi1 = sin(phi1),
            cosPhi1 = cos(phi1),
            delta = lambda1 - lambda0,
            sign = delta >= 0 ? 1 : -1,
            absDelta = sign * delta,
            antimeridian = absDelta > pi,
            k = sinPhi0 * sinPhi1;

        sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign * tau : delta;

        // Are the longitudes either side of the point’s meridian (lambda),
        // and are the latitudes smaller than the parallel (phi)?
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }

    // First, determine whether the South pole is inside or outside:
    //
    // It is inside if:
    // * the polygon winds around it in a clockwise direction.
    // * the polygon does not (cumulatively) wind around it, but has a negative
    //   (counter-clockwise) area.
    //
    // Second, count the (signed) number of times a segment crosses a lambda
    // from the point to the South pole.  If it is zero, then the point is the
    // same side as the South pole.

    return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);

  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  }

  function merge(arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  }

  function clip(pointVisible, clipLine, interpolate, start) {
    return function(sink) {
      var line = clipLine(sink),
          ringBuffer = clipBuffer(),
          ringSink = clipLine(ringBuffer),
          polygonStarted = false,
          polygon,
          segments,
          ring;

      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains(polygon, start);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };

      function point(lambda, phi) {
        if (pointVisible(lambda, phi)) sink.point(lambda, phi);
      }

      function pointLine(lambda, phi) {
        line.point(lambda, phi);
      }

      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }

      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }

      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        ringSink.point(lambda, phi);
      }

      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }

      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();

        var clean = ringSink.clean(),
            ringSegments = ringBuffer.result(),
            i, n = ringSegments.length, m,
            segment,
            point;

        ring.pop();
        polygon.push(ring);
        ring = null;

        if (!n) return;

        // No intersections.
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
            sink.lineEnd();
          }
          return;
        }

        // Rejoin connected segments.
        // TODO reuse ringBuffer.rejoin()?
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

        segments.push(ringSegments.filter(validSegment));
      }

      return clip;
    };
  }

  function validSegment(segment) {
    return segment.length > 1;
  }

  // Intersections are sorted along the clip edge. For both antimeridian cutting
  // and circle clipping, the same comparison is used.
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
         - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
  }

  var clipAntimeridian = clip(
    function() { return true; },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );

  // Takes a line and cuts into visible segments. Return values: 0 - there were
  // intersections or the line was empty; 1 - no intersections; 2 - there were
  // intersections, and the first and last segments should be rejoined.
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN,
        phi0 = NaN,
        sign0 = NaN,
        clean; // no intersections

    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi : -pi,
            delta = abs(lambda1 - lambda0);
        if (abs(delta - pi) < epsilon) { // line crosses a pole
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
          if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
          if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean; // if intersections, rejoin first and last segments
      }
    };
  }

  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0,
        cosPhi1,
        sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon
        ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
            - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
            / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
        : (phi0 + phi1) / 2;
  }

  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function clipCircle(radius) {
    var cr = cos(radius),
        delta = 6 * radians,
        smallRadius = cr > 0,
        notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }

    function visible(lambda, phi) {
      return cos(lambda) * cos(phi) > cr;
    }

    // Takes a line and cuts into visible segments. Return values used for polygon
    // clipping: 0 - there were intersections or the line was empty; 1 - no
    // intersections 2 - there were intersections, and the first and last segments
    // should be rejoined.
    function clipLine(stream) {
      var point0, // previous point
          c0, // code for previous point
          v0, // visibility of previous point
          v00, // visibility of first point
          clean; // no intersections
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi],
              point2,
              v = visible(lambda, phi),
              c = smallRadius
                ? v ? 0 : code(lambda, phi)
                : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          // Handle degeneracies.
          // TODO ignore if not clipping polygons.
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
              point1[0] += epsilon;
              point1[1] += epsilon;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              // outside going in
              stream.lineStart();
              point2 = intersect(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              // inside going out
              point2 = intersect(point0, point1);
              stream.point(point2[0], point2[1]);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            // If the codes for two points are different, or are both zero,
            // and there this segment intersects with the small circle.
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !pointEqual(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | ((v00 && v0) << 1);
        }
      };
    }

    // Intersects the great circle between a and b with the clip circle.
    function intersect(a, b, two) {
      var pa = cartesian(a),
          pb = cartesian(b);

      // We have two planes, n1.p = d1 and n2.p = d2.
      // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
      var n1 = [1, 0, 0], // normal
          n2 = cartesianCross(pa, pb),
          n2n2 = cartesianDot(n2, n2),
          n1n2 = n2[0], // cartesianDot(n1, n2),
          determinant = n2n2 - n1n2 * n1n2;

      // Two polar points.
      if (!determinant) return !two && a;

      var c1 =  cr * n2n2 / determinant,
          c2 = -cr * n1n2 / determinant,
          n1xn2 = cartesianCross(n1, n2),
          A = cartesianScale(n1, c1),
          B = cartesianScale(n2, c2);
      cartesianAddInPlace(A, B);

      // Solve |p(t)|^2 = 1.
      var u = n1xn2,
          w = cartesianDot(A, u),
          uu = cartesianDot(u, u),
          t2 = w * w - uu * (cartesianDot(A, A) - 1);

      if (t2 < 0) return;

      var t = sqrt(t2),
          q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A);
      q = spherical(q);

      if (!two) return q;

      // Two intersection points.
      var lambda0 = a[0],
          lambda1 = b[0],
          phi0 = a[1],
          phi1 = b[1],
          z;

      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

      var delta = lambda1 - lambda0,
          polar = abs(delta - pi) < epsilon,
          meridian = polar || delta < epsilon;

      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

      // Check that the first point is between a and b.
      if (meridian
          ? polar
            ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
            : phi0 <= q[1] && q[1] <= phi1
          : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q1, A);
        return [q, spherical(q1)];
      }
    }

    // Generates a 4-bit vector representing the location of a point relative to
    // the small circle's bounding box.
    function code(lambda, phi) {
      var r = smallRadius ? radius : pi - radius,
          code = 0;
      if (lambda < -r) code |= 1; // left
      else if (lambda > r) code |= 2; // right
      if (phi < -r) code |= 4; // below
      else if (phi > r) code |= 8; // above
      return code;
    }

    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
  }

  function clipLine(a, b, x0, y0, x1, y1) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1],
        t0 = 0,
        t1 = 1,
        dx = bx - ax,
        dy = by - ay,
        r;

    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  var clipMax = 1e9, clipMin = -clipMax;

  // TODO Use d3-polygon’s polygonContains here for the ring check?
  // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

  function clipRectangle(x0, y0, x1, y1) {

    function visible(x, y) {
      return x0 <= x && x <= x1 && y0 <= y && y <= y1;
    }

    function interpolate(from, to, direction, stream) {
      var a = 0, a1 = 0;
      if (from == null
          || (a = corner(from, direction)) !== (a1 = corner(to, direction))
          || comparePoint(from, to) < 0 ^ direction > 0) {
        do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
        while ((a = (a + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function corner(p, direction) {
      return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
          : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
          : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
          : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
    }

    function compareIntersection(a, b) {
      return comparePoint(a.x, b.x);
    }

    function comparePoint(a, b) {
      var ca = corner(a, 1),
          cb = corner(b, 1);
      return ca !== cb ? ca - cb
          : ca === 0 ? b[1] - a[1]
          : ca === 1 ? a[0] - b[0]
          : ca === 2 ? a[1] - b[1]
          : b[0] - a[0];
    }

    return function(stream) {
      var activeStream = stream,
          bufferStream = clipBuffer(),
          segments,
          polygon,
          ring,
          x__, y__, v__, // first point
          x_, y_, v_, // previous point
          first,
          clean;

      var clipStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: polygonStart,
        polygonEnd: polygonEnd
      };

      function point(x, y) {
        if (visible(x, y)) activeStream.point(x, y);
      }

      function polygonInside() {
        var winding = 0;

        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
            if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
            else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
          }
        }

        return winding;
      }

      // Buffer geometry within a polygon and then clip it en masse.
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }

      function polygonEnd() {
        var startInside = polygonInside(),
            cleanInside = clean && startInside,
            visible = (segments = merge(segments)).length;
        if (cleanInside || visible) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible) {
            clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }

      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }

      // TODO rather than special-case polygons, simply handle them separately.
      // Ideally, coincident intersection points should be jittered to avoid
      // clipping issues.
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point;
        if (v_) activeStream.lineEnd();
      }

      function linePoint(x, y) {
        var v = visible(x, y);
        if (polygon) ring.push([x, y]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
          }
        } else {
          if (v && v_) activeStream.point(x, y);
          else {
            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
            if (clipLine(a, b, x0, y0, x1, y1)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a[0], a[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }

      return clipStream;
    };
  }

  var lengthSum = adder();

  function graticuleX(y0, y1, dy) {
    var y = range(y0, y1 - epsilon, dy).concat(y1);
    return function(x) { return y.map(function(y) { return [x, y]; }); };
  }

  function graticuleY(x0, x1, dx) {
    var x = range(x0, x1 - epsilon, dx).concat(x1);
    return function(y) { return x.map(function(x) { return [x, y]; }); };
  }

  function graticule() {
    var x1, x0, X1, X0,
        y1, y0, Y1, Y0,
        dx = 10, dy = dx, DX = 90, DY = 360,
        x, y, X, Y,
        precision = 2.5;

    function graticule() {
      return {type: "MultiLineString", coordinates: lines()};
    }

    function lines() {
      return range(ceil(X0 / DX) * DX, X1, DX).map(X)
          .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
          .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
          .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
    }

    graticule.lines = function() {
      return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
    };

    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X(X0).concat(
          Y(Y1).slice(1),
          X(X1).reverse().slice(1),
          Y(Y0).reverse().slice(1))
        ]
      };
    };

    graticule.extent = function(_) {
      if (!arguments.length) return graticule.extentMinor();
      return graticule.extentMajor(_).extentMinor(_);
    };

    graticule.extentMajor = function(_) {
      if (!arguments.length) return [[X0, Y0], [X1, Y1]];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };

    graticule.extentMinor = function(_) {
      if (!arguments.length) return [[x0, y0], [x1, y1]];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };

    graticule.step = function(_) {
      if (!arguments.length) return graticule.stepMinor();
      return graticule.stepMajor(_).stepMinor(_);
    };

    graticule.stepMajor = function(_) {
      if (!arguments.length) return [DX, DY];
      DX = +_[0], DY = +_[1];
      return graticule;
    };

    graticule.stepMinor = function(_) {
      if (!arguments.length) return [dx, dy];
      dx = +_[0], dy = +_[1];
      return graticule;
    };

    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = graticuleX(y0, y1, 90);
      y = graticuleY(x0, x1, precision);
      X = graticuleX(Y0, Y1, 90);
      Y = graticuleY(X0, X1, precision);
      return graticule;
    };

    return graticule
        .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
        .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
  }

  function identity(x) {
    return x;
  }

  var areaSum$1 = adder(),
      areaRingSum$1 = adder(),
      x00,
      y00,
      x0,
      y0;

  var areaStream = {
    point: noop,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;
      areaSum$1.add(abs(areaRingSum$1));
      areaRingSum$1.reset();
    },
    result: function() {
      var area = areaSum$1 / 2;
      areaSum$1.reset();
      return area;
    }
  };

  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }

  function areaPointFirst(x, y) {
    areaStream.point = areaPoint;
    x00 = x0 = x, y00 = y0 = y;
  }

  function areaPoint(x, y) {
    areaRingSum$1.add(y0 * x - x0 * y);
    x0 = x, y0 = y;
  }

  function areaRingEnd() {
    areaPoint(x00, y00);
  }

  var x0$1 = Infinity,
      y0$1 = x0$1,
      x1 = -x0$1,
      y1 = x1;

  var boundsStream = {
    point: boundsPoint,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop,
    result: function() {
      var bounds = [[x0$1, y0$1], [x1, y1]];
      x1 = y1 = -(y0$1 = x0$1 = Infinity);
      return bounds;
    }
  };

  function boundsPoint(x, y) {
    if (x < x0$1) x0$1 = x;
    if (x > x1) x1 = x;
    if (y < y0$1) y0$1 = y;
    if (y > y1) y1 = y;
  }

  // TODO Enforce positive area for exterior, negative area for interior?

  var X0 = 0,
      Y0 = 0,
      Z0 = 0,
      X1 = 0,
      Y1 = 0,
      Z1 = 0,
      X2 = 0,
      Y2 = 0,
      Z2 = 0,
      x00$1,
      y00$1,
      x0$2,
      y0$2;

  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
          : Z1 ? [X1 / Z1, Y1 / Z1]
          : Z0 ? [X0 / Z0, Y0 / Z0]
          : [NaN, NaN];
      X0 = Y0 = Z0 =
      X1 = Y1 = Z1 =
      X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };

  function centroidPoint(x, y) {
    X0 += x;
    Y0 += y;
    ++Z0;
  }

  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }

  function centroidPointFirstLine(x, y) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidPointLine(x, y) {
    var dx = x - x0$2, dy = y - y0$2, z = sqrt(dx * dx + dy * dy);
    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }

  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }

  function centroidRingEnd() {
    centroidPointRing(x00$1, y00$1);
  }

  function centroidPointFirstRing(x, y) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
  }

  function centroidPointRing(x, y) {
    var dx = x - x0$2,
        dy = y - y0$2,
        z = sqrt(dx * dx + dy * dy);

    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;

    z = y0$2 * x - x0$2 * y;
    X2 += z * (x0$2 + x);
    Y2 += z * (y0$2 + y);
    Z2 += z * 3;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function PathContext(context) {
    this._context = context;
  }

  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x, y);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x, y);
          break;
        }
        default: {
          this._context.moveTo(x + this._radius, y);
          this._context.arc(x, y, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  var lengthSum$1 = adder(),
      lengthRing,
      x00$2,
      y00$2,
      x0$3,
      y0$3;

  var lengthStream = {
    point: noop,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x00$2, y00$2);
      lengthStream.point = noop;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length = +lengthSum$1;
      lengthSum$1.reset();
      return length;
    }
  };

  function lengthPointFirst(x, y) {
    lengthStream.point = lengthPoint;
    x00$2 = x0$3 = x, y00$2 = y0$3 = y;
  }

  function lengthPoint(x, y) {
    x0$3 -= x, y0$3 -= y;
    lengthSum$1.add(sqrt(x0$3 * x0$3 + y0$3 * y0$3));
    x0$3 = x, y0$3 = y;
  }

  function PathString() {
    this._string = [];
  }

  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._string.push("Z");
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x, ",", y);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x, ",", y);
          break;
        }
        default: {
          if (this._circle == null) this._circle = circle(this._radius);
          this._string.push("M", x, ",", y, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };

  function circle(radius) {
    return "m0," + radius
        + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
        + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
        + "z";
  }

  function index(projection, context) {
    var pointRadius = 4.5,
        projectionStream,
        contextStream;

    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }

    path.area = function(object) {
      geoStream(object, projectionStream(areaStream));
      return areaStream.result();
    };

    path.measure = function(object) {
      geoStream(object, projectionStream(lengthStream));
      return lengthStream.result();
    };

    path.bounds = function(object) {
      geoStream(object, projectionStream(boundsStream));
      return boundsStream.result();
    };

    path.centroid = function(object) {
      geoStream(object, projectionStream(centroidStream));
      return centroidStream.result();
    };

    path.projection = function(_) {
      return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
    };

    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path;
    };

    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };

    return path.projection(projection).context(context);
  }

  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream;
      for (var key in methods) s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }

  function TransformStream() {}

  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x, y) { this.stream.point(x, y); },
    sphere: function() { this.stream.sphere(); },
    lineStart: function() { this.stream.lineStart(); },
    lineEnd: function() { this.stream.lineEnd(); },
    polygonStart: function() { this.stream.polygonStart(); },
    polygonEnd: function() { this.stream.polygonEnd(); }
  };

  function fit(projection, fitBounds, object) {
    var clip = projection.clipExtent && projection.clipExtent();
    projection.scale(150).translate([0, 0]);
    if (clip != null) projection.clipExtent(null);
    geoStream(object, projection.stream(boundsStream));
    fitBounds(boundsStream.result());
    if (clip != null) projection.clipExtent(clip);
    return projection;
  }

  function fitExtent(projection, extent, object) {
    return fit(projection, function(b) {
      var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitSize(projection, size, object) {
    return fitExtent(projection, [[0, 0], size], object);
  }

  function fitWidth(projection, width, object) {
    return fit(projection, function(b) {
      var w = +width,
          k = w / (b[1][0] - b[0][0]),
          x = (w - k * (b[1][0] + b[0][0])) / 2,
          y = -k * b[0][1];
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  function fitHeight(projection, height, object) {
    return fit(projection, function(b) {
      var h = +height,
          k = h / (b[1][1] - b[0][1]),
          x = -k * b[0][0],
          y = (h - k * (b[1][1] + b[0][1])) / 2;
      projection.scale(150 * k).translate([x, y]);
    }, object);
  }

  var maxDepth = 16, // maximum depth of subdivision
      cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

  function resample(project, delta2) {
    return +delta2 ? resample$1(project, delta2) : resampleNone(project);
  }

  function resampleNone(project) {
    return transformer({
      point: function(x, y) {
        x = project(x, y);
        this.stream.point(x[0], x[1]);
      }
    });
  }

  function resample$1(project, delta2) {

    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0,
          dy = y1 - y0,
          d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a = a0 + a1,
            b = b0 + b1,
            c = c0 + c1,
            m = sqrt(a * a + b * b + c * c),
            phi2 = asin(c /= m),
            lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
            p = project(lambda2, phi2),
            x2 = p[0],
            y2 = p[1],
            dx2 = x2 - x0,
            dy2 = y2 - y0,
            dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 // perpendicular projected distance
            || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
            || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x00, y00, a00, b00, c00, // first point
          lambda0, x0, y0, a0, b0, c0; // previous point

      var resampleStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
        polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
      };

      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }

      function lineStart() {
        x0 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }

      function linePoint(lambda, phi) {
        var c = cartesian([lambda, phi]), p = project(lambda, phi);
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }

      function lineEnd() {
        resampleStream.point = point;
        stream.lineEnd();
      }

      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }

      function ringPoint(lambda, phi) {
        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }

      function ringEnd() {
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }

      return resampleStream;
    };
  }

  var transformRadians = transformer({
    point: function(x, y) {
      this.stream.point(x * radians, y * radians);
    }
  });

  function transformRotate(rotate) {
    return transformer({
      point: function(x, y) {
        var r = rotate(x, y);
        return this.stream.point(r[0], r[1]);
      }
    });
  }

  function scaleTranslate(k, dx, dy) {
    function transform(x, y) {
      return [dx + k * x, dy - k * y];
    }
    transform.invert = function(x, y) {
      return [(x - dx) / k, (dy - y) / k];
    };
    return transform;
  }

  function scaleTranslateRotate(k, dx, dy, alpha) {
    var cosAlpha = cos(alpha),
        sinAlpha = sin(alpha),
        a = cosAlpha * k,
        b = sinAlpha * k,
        ai = cosAlpha / k,
        bi = sinAlpha / k,
        ci = (sinAlpha * dy - cosAlpha * dx) / k,
        fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x, y) {
      return [a * x - b * y + dx, dy - b * x - a * y];
    }
    transform.invert = function(x, y) {
      return [ai * x - bi * y + ci, fi - bi * x - ai * y];
    };
    return transform;
  }

  function projectionMutator(projectAt) {
    var project,
        k = 150, // scale
        x = 480, y = 250, // translate
        lambda = 0, phi = 0, // center
        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
        alpha = 0, // post-rotate
        theta = null, preclip = clipAntimeridian, // pre-clip angle
        x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
        delta2 = 0.5, // precision
        projectResample,
        projectTransform,
        projectRotateTransform,
        cache,
        cacheStream;

    function projection(point) {
      return projectRotateTransform(point[0] * radians, point[1] * radians);
    }

    function invert(point) {
      point = projectRotateTransform.invert(point[0], point[1]);
      return point && [point[0] * degrees, point[1] * degrees];
    }

    projection.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };

    projection.preclip = function(_) {
      return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
    };

    projection.postclip = function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    };

    projection.clipAngle = function(_) {
      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
    };

    projection.clipExtent = function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    projection.scale = function(_) {
      return arguments.length ? (k = +_, recenter()) : k;
    };

    projection.translate = function(_) {
      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
    };

    projection.center = function(_) {
      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
    };

    projection.rotate = function(_) {
      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
    };

    projection.angle = function(_) {
      return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
    };

    projection.precision = function(_) {
      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
    };

    projection.fitExtent = function(extent, object) {
      return fitExtent(projection, extent, object);
    };

    projection.fitSize = function(size, object) {
      return fitSize(projection, size, object);
    };

    projection.fitWidth = function(width, object) {
      return fitWidth(projection, width, object);
    };

    projection.fitHeight = function(height, object) {
      return fitHeight(projection, height, object);
    };

    function recenter() {
      var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
          transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose(project, transform);
      projectRotateTransform = compose(rotate, projectTransform);
      projectResample = resample(projectTransform, delta2);
      return reset();
    }

    function reset() {
      cache = cacheStream = null;
      return projection;
    }

    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return recenter();
    };
  }

  var atan2$1 = Math.atan2;
  var cos$1 = Math.cos;
  var sin$1 = Math.sin;
  var pi$1 = Math.PI;
  var halfPi$1 = pi$1 / 2;
  var degrees$1 = 180 / pi$1;
  var radians$1 = pi$1 / 180;

  function asin$1(x) {
    return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
  }

  function acos$1(x) {
    return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
  }

  function sqrt$1(x) {
    return x > 0 ? Math.sqrt(x) : 0;
  }

  // TODO generate on-the-fly to avoid external modification.
  var octahedron = [
    [0, 90],
    [-90, 0], [0, 0], [90, 0], [180, 0],
    [0, -90]
  ];

  [
    [0, 2, 1],
    [0, 3, 2],
    [5, 1, 2],
    [5, 2, 3],
    [0, 1, 4],
    [0, 4, 3],
    [5, 4, 1],
    [5, 3, 4]
  ].map(function(face) {
    return face.map(function(i) {
      return octahedron[i];
    });
  });

  var K = [
    [0.9986, -0.062],
    [1.0000, 0.0000],
    [0.9986, 0.0620],
    [0.9954, 0.1240],
    [0.9900, 0.1860],
    [0.9822, 0.2480],
    [0.9730, 0.3100],
    [0.9600, 0.3720],
    [0.9427, 0.4340],
    [0.9216, 0.4958],
    [0.8962, 0.5571],
    [0.8679, 0.6176],
    [0.8350, 0.6769],
    [0.7986, 0.7346],
    [0.7597, 0.7903],
    [0.7186, 0.8435],
    [0.6732, 0.8936],
    [0.6213, 0.9394],
    [0.5722, 0.9761],
    [0.5322, 1.0000]
  ];

  K.forEach(function(d) {
    d[1] *= 1.0144;
  });

  function satelliteVerticalRaw(P) {
    function forward(lambda, phi) {
      var cosPhi = cos$1(phi),
          k = (P - 1) / (P - cosPhi * cos$1(lambda));
      return [
        k * cosPhi * sin$1(lambda),
        k * sin$1(phi)
      ];
    }

    forward.invert = function(x, y) {
      var rho2 = x * x + y * y,
          rho = sqrt$1(rho2),
          sinc = (P - sqrt$1(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
      return [
        atan2$1(x * sinc, rho * sqrt$1(1 - sinc * sinc)),
        rho ? asin$1(y * sinc / rho) : 0
      ];
    };

    return forward;
  }

  function satelliteRaw(P, omega) {
    var vertical = satelliteVerticalRaw(P);
    if (!omega) return vertical;
    var cosOmega = cos$1(omega),
        sinOmega = sin$1(omega);

    function forward(lambda, phi) {
      var coordinates = vertical(lambda, phi),
          y = coordinates[1],
          A = y * sinOmega / (P - 1) + cosOmega;
      return [
        coordinates[0] * cosOmega / A,
        y / A
      ];
    }

    forward.invert = function(x, y) {
      var k = (P - 1) / (P - 1 - y * sinOmega);
      return vertical.invert(k * x, k * y * cosOmega);
    };

    return forward;
  }

  function geoSatellite() {
    var distance = 2,
        omega = 0,
        m = projectionMutator(satelliteRaw),
        p = m(distance, omega);

    // As a multiple of radius.
    p.distance = function(_) {
      if (!arguments.length) return distance;
      return m(distance = +_, omega);
    };

    p.tilt = function(_) {
      if (!arguments.length) return omega * degrees$1;
      return m(distance, omega = _ * radians$1);
    };

    return p
        .scale(432.147)
        .clipAngle(acos$1(1 / distance) * degrees$1 - 1e-6);
  }

  function identity$1(x) {
    return x;
  }

  function transform(transform) {
    if (transform == null) return identity$1;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2, n = input.length, output = new Array(n);
      output[0] = (x0 += input[0]) * kx + dx;
      output[1] = (y0 += input[1]) * ky + dy;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n;
    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function feature(topology, o) {
    return o.type === "GeometryCollection"
        ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
        : feature$1(topology, o);
  }

  function feature$1(topology, o) {
    var id = o.id,
        bbox = o.bbox,
        properties = o.properties == null ? {} : o.properties,
        geometry = object(topology, o);
    return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
        : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
        : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
  }

  function object(topology, o) {
    var transformPoint = transform(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
        points.push(transformPoint(a[k], k));
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      return transformPoint(p);
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var type = o.type, coordinates;
      switch (type) {
        case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
        case "Point": coordinates = point(o.coordinates); break;
        case "MultiPoint": coordinates = o.coordinates.map(point); break;
        case "LineString": coordinates = line(o.arcs); break;
        case "MultiLineString": coordinates = o.arcs.map(line); break;
        case "Polygon": coordinates = polygon(o.arcs); break;
        case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
        default: return null;
      }
      return {type: type, coordinates: coordinates};
    }

    return geometry(o);
  }

  function initView(porthole, fieldOfView) {
    // The porthole is an HTML element acting as a window into a 3D world
    // fieldOfView is the vertical view angle range in degrees (floating point)

    // Compute values for transformation between the 3D world and the 2D porthole
    var portRect, width, height, aspect;
    var tanFOV = Math.tan(fieldOfView * Math.PI / 180.0 / 2.0);
    const maxRay = [];

    computeRayParams(); // Set initial values

    return {
      element: porthole, // Back-reference
      changed: computeRayParams,

      width: () => width,
      height: () => height,
      topEdge: () => maxRay[1],   // tanFOV
      rightEdge: () => maxRay[0], // aspect * tanFOV
      maxRay, // TODO: is it good to expose local state?
      getRayParams,
    };

    function computeRayParams() {
      // Compute porthole size
      portRect = porthole.getBoundingClientRect();
      let newWidth = portRect.right - portRect.left;
      let newHeight = portRect.bottom - portRect.top;

      // Exit if no change
      if (width === newWidth && height === newHeight) return false;

      // Update stored values
      width = newWidth;
      height = newHeight;
      aspect = width / height;
      maxRay[0] = aspect * tanFOV;
      maxRay[1] = tanFOV; // Probably no change, but it is exposed externally

      // Let the calling program know that the porthole changed
      return true;
    }

    // Convert a position on the screen into tangents of the angles
    // (relative to screen normal) of a ray shooting off into the 3D space
    function getRayParams(rayVec, clientX, clientY) {
      // NOTE strange behavior of getBoundingClientRect()
      // rect.left and .top are equal to the coordinates given by clientX/Y
      // when the mouse is at the left top pixel in the box.
      // rect.right and .bottom are NOT equal to clientX/Y at the bottom
      // right pixel -- they are one more than the clientX/Y values.
      // Thus the number of pixels in the box is given by 
      //    porthole.clientWidth = rect.right - rect.left  (NO +1 !!)
      var x = clientX - portRect.left;
      var y = portRect.bottom - clientY - 1; // Flip sign to make +y upward

      // Normalized distances from center of box. We normalize by pixel DISTANCE
      // rather than pixel count, to ensure we get -1 and +1 at the ends.
      // (Confirm by considering the 2x2 case)
      var xratio = 2 * x / (width - 1) - 1;
      var yratio = 2 * y / (height - 1) -1;

      rayVec[0] = xratio * maxRay[0];
      rayVec[1] = yratio * maxRay[1];
      //rayVec[2] = -1.0;
      //rayVec[3] = 0.0;
      return;
    }
  }

  function initCursor() {
    // What does an animation need to know about the cursor at each frame?
    // First, whether the user did any of the following since the last frame:
    //  - Started new actions
    var touchStarted = false; // Touched or clicked the element
    var zoomStarted  = false; // Rotated mousewheel, or started two-finger touch
    //  - Changed something
    var moved  = false;       // Moved mouse or touch point
    var zoomed = false;       // Rotated mousewheel, or adjusted two-finger touch
    //  - Is potentially in the middle of something
    var tapping = false;      // No touchEnd, and no cursor motion
    //  - Ended actions
    var touchEnded = false;   // mouseup or touchend/cancel/leave
    var tapped = false;       // Completed a click or tap action

    // We also need to know the current cursor position and zoom scale
    var cursorX = 0;
    var cursorY = 0;
    var zscale = 1.0;

    // For tap/click reporting, we need to remember where the touch started
    var startX = 0;
    var startY = 0;
    // What is a click/tap and what is a drag? If the cursor moved more than
    // this threshold between touchStart and touchEnd, it is a drag
    const threshold = 6;

    return {
      // Methods to report local state. These protect local values, returning a copy
      touchStarted: () => touchStarted,
      zoomStarted:  () => zoomStarted,
      moved:        () => moved,
      zoomed:       () => zoomed,
      tapped:       () => tapped,
      touchEnded:   () => touchEnded,
      hasChanged:   () => (moved || zoomed || tapped),
      zscale:       () => zscale,
      x: () => cursorX,
      y: () => cursorY,

      // Methods to update local state
      startTouch,
      startZoom,
      move,
      zoom,
      endTouch,
      reset,
    };

    function startTouch(evnt) {
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      touchStarted = true;
      startX = cursorX;
      startY = cursorY;
      tapping = true;
    }

    function startZoom(evnt) {
      // Store the cursor position
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      zoomStarted = true;
      tapping = false;
    }

    function move(evnt) {
      cursorX = evnt.clientX;
      cursorY = evnt.clientY;
      moved = true;
      var dist = Math.abs(cursorX - startX) + Math.abs(cursorY - startY);
      if (dist > threshold) tapping = false;
    }

    function zoom(scale) {
      zscale *= scale;
      zoomed = true;
      tapping = false;
    }

    function endTouch() {
      if (touchStarted) {
        // Ending a new touch? Just ignore both // TODO: is this a good idea?
        touchStarted = false;
        touchEnded = false;
      } else {
        touchEnded = true;
      }
      tapped = tapping;
      tapping = false;
    }

    function reset() {
      touchStarted = false;
      zoomStarted  = false;
      moved  = false;
      zoomed = false;
      touchEnded = false;
      // NOTE: we do NOT reset tapping... this could carry over to next check
      tapped = false;
      zscale = 1.0;
    }
  }

  // Add event listeners to update the state of a cursor object
  // Input div is an HTML element on which events will be registered
  function initTouch(div) {
    const cursor = initCursor();

    // Remember the distance between two pointers
    var lastDistance = 1.0;
    
    // Capture the drag event so we can disable any default actions
    div.addEventListener('dragstart', function(drag) {
      drag.preventDefault();
      return false;
    }, false);

    // Add mouse events
    div.addEventListener('mousedown',   cursor.startTouch, false);
    div.addEventListener('mousemove',   cursor.move,       false);
    div.addEventListener('mouseup',     cursor.endTouch,   false);
    div.addEventListener('mouseleave',  cursor.endTouch,   false);
    div.addEventListener('wheel',       wheelZoom,         false);

    // Add touch events
    div.addEventListener('touchstart',  initTouch,       false);
    div.addEventListener('touchmove',   moveTouch,       false);
    div.addEventListener('touchend',    cursor.endTouch, false);
    div.addEventListener('touchcancel', cursor.endTouch, false);

    // Return a pointer to the cursor object
    return cursor;

    function initTouch(evnt) {
      evnt.preventDefault();
      switch (evnt.touches.length) {
        case 1: 
          cursor.startTouch(evnt.touches[0]);
          break;
        case 2:
          var midpoint = getMidPoint(evnt.touches[0], evnt.touches[1]);
          cursor.startTouch(midpoint);
          cursor.startZoom(midpoint);
          // Initialize the starting distance between touches
          lastDistance = midpoint.distance;
          break;
        default:
          cursor.endTouch(evnt);
      }
    }

    function moveTouch(evnt) {
      evnt.preventDefault();
      // NOTE: MDN says to add the touchmove handler within the touchstart handler
      // https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Using_Touch_Events
      switch (evnt.touches.length) {
        case 1:
          cursor.move(evnt.touches[0]);
          break;
        case 2:
          var midpoint = getMidPoint(evnt.touches[0], evnt.touches[1]);
          // Move the cursor to the midpoint
          cursor.move(midpoint);
          // Zoom based on the change in distance between the two touches
          cursor.zoom(lastDistance / midpoint.distance);
          // Remember the new touch distance
          lastDistance = midpoint.distance;
          break;
        default:
          return false;
      }
    }

    // Convert a two-touch event to a single event at the midpoint
    function getMidPoint(p0, p1) {
      var dx = p1.clientX - p0.clientX;
      var dy = p1.clientY - p0.clientY;
      return {
        clientX: p0.clientX + dx / 2,
        clientY: p0.clientY + dy / 2,
        distance: Math.sqrt(dx * dx + dy * dy),
      }
    }

    function wheelZoom(turn) {
      turn.preventDefault();
      cursor.startZoom(turn);
      // We ignore the dY from the browser, since it may be arbitrarily scaled
      // based on screen resolution or other factors. We keep only the sign.
      // See https://github.com/Leaflet/Leaflet/issues/4538
      var zoomScale = 1.0 + 0.2 * Math.sign(turn.deltaY);
      cursor.zoom(zoomScale);
    }
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */

  function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to transform
   * @param {mat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  function initEcefToLocalGeo() {
    var p, p2, sinLon, cosLon, sinLat, cosLat;
    const toENU = new Float64Array(9);

    return ecefToDeltaLonLatAlt;

    function ecefToDeltaLonLatAlt( delta, diff, anchor, viewPos ) {
      // Inputs are pointers to vec3s. anchor is a position in ECEF coordinates.
      // diff represents a differential change (e.g. motion?) near anchor.
      // Output delta will be the corresponding differentials in lon/lat/alt
      // viewPos represents the position of the model coordinates (ECEF) relative
      // to the view coordinates.    WARNING: diff will be overwritten

      // 1. Transform to local East-North-Up coordinates at the anchor location
      setupENU( anchor );
      transformMat3( diff, diff, toENU );

      // 2. Convert horizontal component to changes in longitude, latitude
      let r = length(anchor);
      delta[0] = diff[0] / r / (cosLat + 0.0001); // +0.0001 avoids /0
      delta[1] = diff[1] / r;
      delta[2] = diff[2];
      
      // 3. Latitudinal change is a rotation about an axis in the x-z plane, with
      // direction vec3.cross(anchor,North), or -East. We only want the component
      // rotating about the x-axis in view coordinates.
      delta[1] *= (
          Math.cos(viewPos[0]) * cosLon +
          Math.sin(viewPos[0]) * sinLon 
          );
      return;
    }

    function setupENU( normal ) {
      // Setup the matrix to rotate from global Earth-Centered-Earth-Fixed
      // to local East-North-Up coordinates. Assumptions for input ECEF:
      //    y-axis is the polar axis
      //   +z-axis points toward latitude = longitude = 0.
      // Input normal is an ellipsoid surface normal at the desired ENU origin

      // Update sines and cosines of the latitude and longitude of the normal
      p2 = normal[0]**2 + normal[2]**2;
      p = Math.sqrt(p2);
      if (p > 0) {
        sinLon = normal[0] / p;
        cosLon = normal[2] / p;
      } else {
        sinLon = 0.0;
        cosLon = 0.0;
      }
      let r = Math.sqrt(p2 + normal[1]**2);
      sinLat = normal[1] / r;
      cosLat = p / r;

      // Build matrix. Follows Widnal & Peraire (MIT) p.7, with the axes renamed:
      //   z -> y, y -> x, x -> z
      // Using OpenGL COLUMN-MAJOR format!!
      toENU[0] =  cosLon;
      toENU[1] = -sinLat * sinLon;
      toENU[2] =  cosLat * sinLon;

      toENU[3] =  0.0;
      toENU[4] =  cosLat;
      toENU[5] =  sinLat;

      toENU[6] = -sinLon;
      toENU[7] = -sinLat * cosLon;
      toENU[8] =  cosLat * cosLon;
      // Note: the rows of the matrix are the unit vectors along each axis:
      // Elements (0, 3, 6) = unit vector in East direction
      // Elements (1, 4, 7) = unit vector in North direction
      // Elements (2, 5, 8) = unit vector in Up direction
      return;
    }
  }

  function initEllipsoid() {
    // Store ellipsoid parameters
    const semiMajor = 6371.0;  // kilometers
    const semiMinor = 6371.0;  // kilometers

    const e2 = 1.0 - semiMinor**2 / semiMajor**2; // Ellipticity squared
    // Mean radius as defined by the International Union of Geodesy and Geophysics
    // See https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
    const meanRadius = (2.0 * semiMajor + semiMinor) / 3.0;

    var p, p2, sinLat, primeVertRad;

    // Working vectors for shootEllipsoid, findHorizon
    const mCam = new Float64Array(3);
    const mRay = new Float64Array(3);
    const dRay = new Float64Array(3);

    return {
      meanRadius: () => meanRadius,
      ecef2geocentric,
      ecefToDeltaLonLatAlt: initEcefToLocalGeo(),
      geodetic2ecef,
      shoot: shootEllipsoid,
      findHorizon,
    };

    function ecef2geocentric( gcPos, ecefPos ) {
      // Output gcPos is a pointer to a 3-element array, containing geocentric
      //  longitude & latitude (radians) and altitude (meters) coordinates
      // Input ecefPos is a pointer to a 3-element array, containing earth-
      //  centered earth-fixed x,y,z coordinates in the WebGL axis definition

      // Note: order of calculations is chosen to allow calls with same array
      // as input & output (gcPos, ecefPos point to same array)
      p2 = ecefPos[0]**2 + ecefPos[2]**2; // Squared distance from polar axis

      gcPos[0] = Math.atan2( ecefPos[0], ecefPos[2] );     // Longitude

      // NOTE: this "altitude" is distance from SPHERE, not ellipsoid
      gcPos[2] = Math.sqrt( p2 + ecefPos[1]**2 ) - meanRadius; // Altitude

      gcPos[1] = Math.atan2( ecefPos[1], Math.sqrt(p2) );  // Latitude
      return;
    }

    function geodetic2ecef( ecef, geodetic ) {
      // Output ecef is a pointer to a 3-element array containing X,Y,Z values
      //   of the point in earth-centered earth-fixed (ECEF) coordinates
      // Input geodetic is a pointer to a 3-element array, containing
      //   longitude & latitude (in radians) and altitude (in meters)

      // Start from prime vertical radius of curvature -- see
      // https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
      sinLat = Math.sin( geodetic[1] );
      primeVertRad = semiMajor / Math.sqrt( 1.0 - e2 * sinLat**2 );
      // Radial distance from y-axis:
      p = (primeVertRad + geodetic[2]) * Math.cos(geodetic[1]);

      // Compute ECEF position
      ecef[0] = p * Math.sin(geodetic[0]);
      ecef[1] = (primeVertRad + geodetic[2]) * sinLat * (1.0 - e2);
      ecef[2] = p * Math.cos(geodetic[0]);
      return;
    }

    function shootEllipsoid(intersection, camera, rayVec) {
      // Inputs camera, rayVec are pointers to vec3s indicating the
      //   position of the camera and the direction of a ray shot from the camera,
      //   both in earth-centered earth-fixed (ECEF) coordinates
      // Output intersection is a pointer to a vec3 in ECEF coordinates indicating
      //   the position of the intersection of the ray with the ellipsoid
      // Return value indicates whether the ray did in fact intersect the spheroid

      // Math: solving for values t where || M (camera + t*rayVec) || = 1,
      //  where M is the matrix that scales the ellipsoid to the unit sphere,
      //  i.e., for P = (x,y,z), MP = (x/a, y/b, z/c). Since M is diagonal
      //  (ellipsoid aligned along coordinate axes) we just scale each coordinate.
      mCam.set([
          camera[0] / semiMajor, 
          camera[1] / semiMinor,
          camera[2] / semiMajor 
      ]);
      mRay.set([
          rayVec[0] / semiMajor, 
          rayVec[1] / semiMinor, 
          rayVec[2] / semiMajor 
      ]);

      // We now have <mRay,mRay>*t^2 + 2*<mRay,mCam>*t + <mCam,mCam> - 1 = 0
      var a = dot(mRay, mRay);
      var b = 2.0 * dot(mRay, mCam);
      var c = dot(mCam, mCam) - 1.0;
      var discriminant = b**2 - 4*a*c;

      var intersected, t;
      if (discriminant < 0) {
        intersected = false;
        // Find the point that comes closest to the unit sphere
        //   NOTE: this is NOT the closest point to the ellipsoid!
        //   And it is not even the point on the horizon! It is closer...
        // Minimize a*t^2 + b*t + c, by finding the zero of the derivative
        t = -0.5 * b / a;
      } else {
        intersected = true;
        // We want the closest intersection, with smallest positive t
        // We assume b < 0, if ray is pointing back from camera to ellipsoid
        t = (-b - Math.sqrt(discriminant)) / (2.0*a);
      }

      // NOTE: rayVec is actually a vec4
      scaleAndAdd(intersection, camera, rayVec, t);
      return intersected;
    }

    function findHorizon(horizon, camera, rayVec) {
      // Find the point on the horizon under rayvec.
      // We first adjust rayVec to point it toward the horizon, and then
      // re-shoot the ellipsoid with the corrected ray

      // 1. Find the component of rayVec parallel to camera direction
      normalize(dRay, camera); // Unit vector along camera direction
      var paraLength = dot(dRay, rayVec);
      scale( dRay, dRay, paraLength );

      // 2. Find the component perpendicular to camera direction
      subtract( dRay, rayVec, dRay );
      var perpLength = length(dRay);
      if (perpLength == 0) return false; // No solution if ray is vertical

      // 3. Find the error of the length of the perpendicular component
      var sinAlpha = meanRadius / length(camera); // sin(angle to horizon)
      var tanAlpha = sinAlpha / Math.sqrt(1.0 - sinAlpha * sinAlpha);
      var dPerp = -paraLength * tanAlpha - perpLength;

      // 4. Find the corrected rayVec
      scaleAndAdd(dRay, rayVec, dRay, dPerp / perpLength);

      // 5. Re-shoot the ellipsoid with the corrected rayVec
      shootEllipsoid(horizon, camera, dRay);

      return true;
    }
  }

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }

  function initECEF(ellipsoid, initialPos) {
    // From the geodetic position, we derive Earth-Centered Earth-Fixed (ECEF)
    // coordinates and a rotation matrix
    // These are suitable for rendering Relative To Eye (RTE), as described in
    // P Cozzi, 3D Engine Design for Virtual Globes, www.virtualglobebook.com
    const position = new Float64Array([0.0, 0.0, 0.0, 1.0]);
    const rotation = create$1();  // Note: single precision!! (Float32Array)
    const inverse  = create$1();

    const halfPi = Math.PI / 2.0;

    // Set initial values
    update(initialPos);

    return {
      position, // WARNING: Exposes local array to changes from outside
      rotation,
      inverse,
      update,
    };

    function update(geodetic) {
      // Limit rotation around screen x-axis to keep global North pointing up
      geodetic[1] = Math.min(Math.max(-halfPi, geodetic[1]), halfPi);
      // Avoid accumulation of large values in longitude
      if (geodetic[0] >  Math.PI) geodetic[0] -= 2.0 * Math.PI;
      if (geodetic[0] < -Math.PI) geodetic[0] += 2.0 * Math.PI;

      // Compute ECEF coordinates. NOTE WebGL coordinate convention: 
      // +x to right, +y to top of screen, and +z into the screen
      ellipsoid.geodetic2ecef( position, geodetic );

      // Rotation: y first, so it will be left of x operator in final matrix
      // (gl-matrix library 'post-multplies' by each new matrix)
      // Positive angles about Y are towards the +X axis, or East longitude.
      fromYRotation( rotation, geodetic[0] );
      // Positive angles about X are towards the -Y axis!
      // (from Y to Z, and Z to -Y). But geodetic[1] is a latitude, toward N
      rotateX( rotation, rotation, -geodetic[1] );

      // The inverse of a rotation matrix is its transpose
      transpose( inverse, rotation );
    }
  }

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  function initEdgePoints(ellipsoid, camPos, camRot, screen) {
    // Allocate working arrays and variables
    const rayVec = new Float64Array([0.0, 0.0, -1.0, 0.0]);
    const camRay = new Float64Array(4);
    const rayHit = new Float64Array(3);
    var tanX, tanY;

    // Construct a list of points around the screen edges
    const screenPoints = [
      [-1.0, -1.0], // Bottom left
      [-0.5, -1.0],
      [ 0.0, -1.0], // Bottom center
      [ 0.5, -1.0],
      [ 1.0, -1.0], // Bottom right
      [ 1.0, -0.5],
      [ 1.0,  0.0], // Right center
      [ 1.0,  0.5],
      [ 1.0,  1.0], // Top right
      [ 0.5,  1.0],
      [ 0.0,  1.0], // Top center
      [-0.5,  1.0],
      [-1.0,  1.0], // Top left
      [-1.0,  0.5],
      [-1.0,  0.0], // Left center
      [-1.0, -0.5],
      [-1.0, -1.0], // Loop back to bottom left
    ];

    // An edgePoint is the point on the ellipsoid visible from screenPoint
    const edgePoints = [];
    screenPoints.forEach( (point, index) => { 
      edgePoints[index] = [];
    });
    update();

    return {
      lonLats: edgePoints,  // WARNING: exposed to updates from outside!
      update,
    };

    function update() {
      // Update the view angles at the screen edges
      tanX = screen.rightEdge();
      tanY = screen.topEdge();

      // Find the ellipsoid intersection at each screen point
      screenPoints.forEach(shoot);
    }

    function shoot(screenPos, index) {
      // Construct the ray vector
      rayVec[0] = screenPos[0] * tanX;
      rayVec[1] = screenPos[1] * tanY;
      // Rotate to model coordinates (Earth-Centered Earth-Fixed)
      transformMat4$1(camRay, rayVec, camRot);

      // Find intersection of ray with ellipsoid
      var hit = ellipsoid.shoot(rayHit, camPos, camRay);
      // If it didn't intersect, find the nearest point on the horizon
      if (!hit) ellipsoid.findHorizon(rayHit, camPos, camRay);

      // Convert to longitude/latitude. NOTE: geocentric!!
      ellipsoid.ecef2geocentric(rayHit, rayHit);

      edgePoints[index][0] = rayHit[0];
      edgePoints[index][1] = rayHit[1];
    }
  }

  function updateOscillator(pos, vel, ext, w0, dt, i1, i2) {
    // Update position and velocity for a critically damped oscillator, following
    // http://mathworld.wolfram.com/CriticallyDampedSimpleHarmonicMotion.html
    
    // Inputs/outputs pos, vel are pointers to arrays
    // Inputs w0, t are primitive floating point values, indicating the
    //   natural frequency of the oscillator and the time step
    // Inputs i1, i2 are primitive integer values, indicating components to update

    var expTerm = Math.exp( -w0 * dt );

    for (let i = i1; i <= i2; i++) {
      var tmp = (vel[i] + w0 * ext[i]) * dt * expTerm;
      vel[i] += (expTerm - 1) * vel[i] - w0 * tmp;
      pos[i] += (expTerm - 1) * ext[i] + tmp;
    }
    return;
  }

  // initZoom: Update camera altitude based on target set by mouse wheel events
  //  or two-finger pinch movements
  function initZoom( ellipsoid ) {
    const w0 = 14.14; // Natural frequency of oscillator
    const minHeight = ellipsoid.meanRadius() * 0.00001;
    const maxHeight = ellipsoid.meanRadius() * 8.0;
    const minVelocity = 0.001;
    const maxRotation = 0.15;

    // NOTE: everything below ASSUMES mass = 1
    var minEnergy = 0.5 * minVelocity * minVelocity;
    var extension, kineticE, potentialE;
    const dPos = new Float64Array(3);

    return function( position, velocity, cursor3d, deltaTime, track ) {
      // Input cursor3d is a pointer to an object
      // Inputs position, velocity are pointers to 3-element arrays
      // Input deltaTime is a primitive floating point value

      var targetHeight = cursor3d.zoomTarget();

      // Save old altitude
      var oldAltitude = position[2];

      dPos[2] = position[2] - targetHeight;
      updateOscillator(position, velocity, dPos, w0, deltaTime, 2, 2);

      if (track) {
        // Adjust rotation to keep zoom location fixed on screen
        dPos.set(position);
        dragonflyStalk( dPos, cursor3d.zoomRay, cursor3d.zoomPosition, ellipsoid );
        // Restrict size of rotation in one time step
        subtract( dPos, dPos, position );
        var limited = limitRotation( dPos, maxRotation );
        add$1( position, position, dPos );
      }

      // Scale rotational velocity by the ratio of the height change
      var heightScale = position[2] / oldAltitude;
      velocity[0] *= heightScale;
      velocity[1] *= heightScale;

      if (cursor3d.isClicked() || limited) return;

      // Stop if we are already near steady state
      kineticE = 0.5 * velocity[2] ** 2;
      extension = position[2] - targetHeight;
      potentialE = 0.5 * (w0 * extension) ** 2;
      if (kineticE + potentialE < minEnergy * targetHeight) {
        targetHeight = position[2];
        velocity[2] = 0.0;
        cursor3d.stopZoom();
      }
      return;
    }
  }

  function limitRotation( dPos, maxRotation ) {
    // Input dPos is a pointer to a 2-element array containing lon, lat changes
    // maxRotation is a primitive floating point value

    // Check for longitude value crossing antimeridian
    if (dPos[0] >  Math.PI) dPos[0] -= 2.0 * Math.PI;
    if (dPos[0] < -Math.PI) dPos[0] += 2.0 * Math.PI;

    if (Math.abs(dPos[0]) > maxRotation) {
      var tmp = Math.min(Math.max(-maxRotation, dPos[0]), maxRotation) / dPos[0];
      dPos[0] *= tmp;
      dPos[1] *= tmp;
      return true;
    }
    return false;
  }

  // Given a 3D scene coordinate over which a zoom action was initiated,
  // and a distance between the screen and the center of the 3D scene,
  // compute the rotations required to align the 3D coordinate along
  // the original screen ray.  See
  // https://en.wikipedia.org/wiki/Dragonfly#Motion_camouflage
  // TODO: Clean this up. Just use difference of lat/lon under ray?
  function dragonflyStalk(outRotation, ray, scenePos, ellipsoid) {
    // Output outRotation is a pointer to a vec3
    // Input ray is a pointer to a vec3
    // Input scenePos is a pointer to a 3D cursor object

    // Find the ray-sphere intersection in unrotated model space coordinates
    var target = new Float64Array(3);
    var unrotatedCamPos = [0.0, 0.0, outRotation[2] + length(scenePos)];
    var onEllipse = ellipsoid.shoot(target, unrotatedCamPos, ray);
    if (!onEllipse) return; // No intersection!

    // Find the rotation about the y-axis required to bring scene point into 
    // the  x = target[0]  plane
    // First find distance of scene point from scene y-axis
    var sceneR = Math.sqrt( scenePos[0] ** 2 + scenePos[2] ** 2 );
    // If too short, exit rather than tipping poles out of y-z plane
    if ( sceneR < Math.abs(target[0]) ) return;
    var targetRotY = Math.asin( target[0] / sceneR );
    outRotation[0] = 
      Math.atan2( scenePos[0], scenePos[2] ) - // Y-angle of scene vector
      //Math.asin( target[0] / sceneR );       // Y-angle of target point
      targetRotY;

    // We now know the x and y coordinates of the scene vector after rotation
    // around the y-axis: (x = target[0], y = scenePos[1])
    // Find the z-coordinate so we can compute the remaining required rotation
    var zRotated = sceneR * Math.cos(targetRotY);

    // Find the rotation about the screen x-axis required to bring the scene
    // point into the target y = target[1] plane
    // Assumes 0 angle is aligned along Z, and angle > 0 is rotation toward -y !
    outRotation[1] = 
      Math.atan2( -1 * target[1], target[2] ) -  // X-angle of target point
      Math.atan2( -1 * scenePos[1], zRotated );  // X-angle of scene vector

    return;
  }

  // initRotation: Updates rotations and rotation velocities based on forces
  // applied via a mouse click & drag event.
  function initRotation( ellipsoid ) {
    const w0 = 40.0;
    const extension = new Float64Array(3);

    return function( position, velocity, mouse3d, deltaTime ) {
      // Input mouse3d is a pointer to a mouse object
      // Inputs position, velocity are pointers to vec3s
      // Input deltaTime is a primitive floating point value

      // Find the displacement of the clicked position on the globe
      // from the current mouse position
      subtract( extension, mouse3d.position, mouse3d.clickPosition );

      // Convert to changes in longitude, latitude, and altitude
      ellipsoid.ecefToDeltaLonLatAlt( extension, extension, 
          mouse3d.clickPosition, position );
      // Ignore altitude change for now
      extension[2] = 0.0;

      updateOscillator(position, velocity, extension, w0, deltaTime, 0, 1);
      return;
    }
  }

  // initCoast: Update rotations based on a freely spinning globe (no forces)
  function initCoast( ellipsoid ) {
    const damping = 3.0;
    const radius = ellipsoid.meanRadius();
    const minSpeed = 0.03;

    var dvDamp = 0.0;

    return function( position, velocity, deltaTime ) {
      // Inputs rotation, rotationVel are pointers to 3-element arrays
      // Input deltaTime is a primitive value (floating point)
      // TODO: switch to exact formula? (not finite difference)

      if ( length(velocity) < minSpeed * position[2] / radius ) {
        // Rotation has almost stopped. Go ahead and stop all the way.
        set(velocity, 0.0, 0.0, 0.0);
        return false; // No change to position, no need to re-render
      }

      // Adjust previous velocities for damping over the past time interval
      dvDamp = -1.0 * damping * deltaTime;
      //vec3.scaleAndAdd(velocity, velocity, velocity, dvDamp);
      velocity[0] += velocity[0] * dvDamp;
      velocity[1] += velocity[1] * dvDamp;

      // Update rotations
      //vec3.scaleAndAdd(position, position, velocity, deltaTime);
      position[0] += velocity[0] * deltaTime;
      position[1] += velocity[1] * deltaTime;
      return true;    // Position changed, need to re-render
    };
  }

  function initProjector(ellipsoid, camPosition, camInverse, screen) {
    const rayVec = new Float64Array(3);
    const ecefTmp = new Float64Array(3);

    return {
      ecefToScreenRay,
      lonLatToScreenXY,
    };

    function lonLatToScreenXY(xy, lonLat) {
      ellipsoid.geodetic2ecef(ecefTmp, lonLat);
      let visible = ecefToScreenRay(rayVec, ecefTmp); // Overwrites rayVec!

      xy[0] = screen.width() * ( 1 + rayVec[0] / screen.rightEdge() ) / 2;
      xy[1] = screen.height() * ( 1 - rayVec[1] / screen.topEdge() ) / 2;
      return visible;
    }

    function ecefToScreenRay(screenRay, ecefPosition) {
      // For a given point on the ellipsoid (in ECEF coordinates) find the
      // rayVec from a given camera position that will intersect it
      
      // Translate to camera position
      subtract(rayVec, ecefPosition, camPosition);
      // rayVec now points from camera to ecef. The sign of the
      // dot product tells us whether it is beyond the horizon
      let visible = ( dot(rayVec, ecefPosition) < 0 );

      // Rotate to camera orientation
      transformMat4(screenRay, rayVec, camInverse);

      // Normalize to z = -1
      screenRay[0] /= -screenRay[2];
      screenRay[1] /= -screenRay[2];
      screenRay[2] = -1.0;

      return visible;
    }
  }

  function initCameraDynamics(screen, ellipsoid, initialPosition) {
    // Position & velocity are computed in latitude & longitude in radians, and
    //   altitude defined by distance along surface normal, in the same length
    //   units as semiMajor and semiMinor in ellipsoid.js
    const position = new Float64Array(initialPosition);
    const velocity = new Float64Array(3); // Initializes to [0,0,0]

    // Initialize ECEF position, rotation matrix, inverse, and update method
    const ecef = initECEF(ellipsoid, position);

    // Keep track of the longitude/latitude of the edges of the screen
    const edges = initEdgePoints(ellipsoid, ecef.position, ecef.rotation, screen);
    // Initialize transforms from ellipsoid to screen positions
    const projector = initProjector(ellipsoid, ecef.position, ecef.inverse, screen);

    // Initialize some values and working arrays
    var time = 0.0;
    var deltaTime = 0.0;
    const rayVec = new Float64Array(4);

    // Initialize values & update functions for translations & rotations
    const zoom   = initZoom(ellipsoid);
    const rotate = initRotation(ellipsoid);
    const coast  = initCoast(ellipsoid);
    var needToRender = true;

    // Return methods to read/update state
    return {
      position, // WARNING: Exposes local array to changes from outside
      edgesPos: edges.lonLats,

      ecefPos: ecef.position,
      rotation: ecef.rotation,
      inverse: ecef.inverse,

      lonLatToScreenXY: projector.lonLatToScreenXY,

      update,
      stopCoast,
      stopZoom,
    };

    function stopCoast() {
      velocity[0] = 0.0;
      velocity[1] = 0.0;
    }
    function stopZoom() { 
      velocity[2] = 0.0; 
    }

    function update(newTime, resized, cursor3d) {
      // Input time is a primitive floating point value
      // Input cursor3d is a pointer to an object
      deltaTime = newTime - time;
      time = newTime;
      // If timestep too big, wait till next frame to update physics
      if (deltaTime > 0.25) return resized;

      if ( cursor3d.isClicked() ) {       // Rotate globe based on cursor drag
        rotate( position, velocity, cursor3d, deltaTime );
        needToRender = true;
      } else {                           // Let globe spin freely
        needToRender = coast( position, velocity, deltaTime );
      }
      if ( cursor3d.isZooming() ) {       // Update zoom
        // Update ECEF position and rotation/inverse matrices
        ecef.update(position);
        // Update 2D screen position of 3D zoom position
        var visible = projector.ecefToScreenRay( rayVec, cursor3d.zoomPosition );
        if (visible) {
          if ( cursor3d.isClicked() ) cursor3d.zoomRay.set(rayVec);
          zoom( position, velocity, cursor3d, deltaTime, cursor3d.zoomFixed() );
        } else {
          stopZoom(); // TODO: is this needed? Might want to keep coasting
          cursor3d.stopZoom();
        }
        needToRender = true;
      }

      needToRender = needToRender || resized;
      if (needToRender) {
        ecef.update(position);
        edges.update();
      }
      return needToRender;
    }
  }

  function initCursor3d(getRayParams, ellipsoid, initialPosition) {
    // Input getRayParams is a method from yawgl.screen, converting screen X/Y
    //  to a ray shooting into 3D space
    // Input initialPosition is a geodetic lon/lat/alt vector

    // Cursor positions are computed & stored in ECEF coordinates (x,y,z)
    const cursorPosition = new Float64Array(3);
    const clickPosition = new Float64Array(3);
    const zoomPosition = new Float64Array(3);
    // Derived geocentric longitude, latitude, altitude
    const cursorLonLat = new Float64Array(3);
    // Screen ray for the 2D cursor position
    const cursorRay = new Float64Array([0.0, 0.0, -1.0, 0.0]);

    // Flags about the cursor state
    var onScene = false;
    var clicked = false;
    var zooming = false;
    var wasTapped = false;
    // Whether to fix the screen position of the zoom
    var zoomFix = false;

    // Track target altitude for zooming
    var targetHeight = initialPosition[2];
    const minHeight = ellipsoid.meanRadius() * 0.00001;
    const maxHeight = ellipsoid.meanRadius() * 8.0;
    // Target screen ray for zooming
    const zoomRay = new Float64Array([0.0, 0.0, -1.0, 0.0]);

    // Local working vector
    const ecefRay = new Float64Array(4);

    // Return methods to read/update cursorPosition
    return {
      // POINTERs to local arrays. WARNING: local values can be changed from outside!
      position: cursorPosition, // TODO: why make the name more ambiguous?
      cursorLonLat,
      clickPosition,
      zoomPosition,
      zoomRay,

      // Methods to report local state.
      // These protect the local value, since primitives are passed by value
      isOnScene:  () => onScene,
      isClicked:  () => clicked,
      wasTapped:  () => wasTapped,
      isZooming:  () => zooming,
      zoomFixed:  () => zoomFix,
      zoomTarget: () => targetHeight,

      // Functions to update local state
      update,
      stopZoom,
    };

    function update(cursor2d, camera) {
      // Get screen ray in model coordinates (ECEF)
      getRayParams(cursorRay, cursor2d.x(), cursor2d.y());
      transformMat4$1(ecefRay, cursorRay, camera.rotation);

      // Find intersection of ray with ellipsoid
      onScene = ellipsoid.shoot(cursorPosition, camera.ecefPos, ecefRay);
      if (!onScene) {
        clicked = false;
        stopZoom(camera.position[2]);
        cursor2d.reset();
        return;
      }

      // Update cursor longitude/latitude
      ellipsoid.ecef2geocentric(cursorLonLat, cursorPosition);

      if ( cursor2d.touchEnded() ) {
        clicked = false;
        zoomFix = false;
      }
      wasTapped = cursor2d.tapped();

      if ( cursor2d.touchStarted() ) {
        // Set click position
        clicked = true;
        clickPosition.set(cursorPosition);
        // Assuming this is a click or single touch, stop zooming
        stopZoom(camera.position[2]);
        // Also stop any coasting in the altitude direction
        camera.stopZoom();
        // If this was actually a two-touch zoom, then cursor2d.zoomStarted()...
      }

      if ( cursor2d.zoomStarted() ) {
        zooming = true;
        zoomFix = true;
        zoomPosition.set(cursorPosition);
        zoomRay.set(cursorRay);
        if (!clicked) camera.stopCoast();
      }

      if ( cursor2d.zoomed() ) {
        zooming = true;
        targetHeight *= cursor2d.zscale();
        targetHeight = Math.min(Math.max(minHeight, targetHeight), maxHeight);
      }

      cursor2d.reset();
      return;
    }

    function stopZoom(height) {
      zooming = false;
      zoomFix = false;
      if (height !== undefined) targetHeight = height;
    }
  }

  const degrees$2 = 180.0 / Math.PI;

  function init(display, center, altitude) {
    // Input display is an HTML element where the ball will be represented
    // Input center is a pointer to a 2-element array containing initial
    // longitude and latitude for the camera
    // Input altitude is a floating point value indicating initial altitude

    // Add event handlers and position tracking to display element
    const cursor2d = initTouch(display);
    // Add a view object to compute ray parameters at points on the display
    const view = initView(display, 25.0);

    // Initialize ellipsoid, and methods for computing positions relative to it
    const ellipsoid = initEllipsoid();

    // Initialize camera dynamics: time, position, velocity, etc.
    // First check and convert user parameters for initial position
    var initialPos = (center && Array.isArray(center) && center.length === 2)
      ? [center[0] / degrees$2, center[1] / degrees$2]
      : [0.0, 0.0];
    initialPos[2] = (altitude)
      ? altitude
      : 4.0 * ellipsoid.meanRadius();
    const camera = initCameraDynamics(view, ellipsoid, initialPos);

    // Initialize interaction with the ellipsoid via the mouse and screen
    const cursor3d = initCursor3d(view.getRayParams, ellipsoid, camera.position);

    var camMoving, cursorChanged;

    return {
      view,

      radius:    ellipsoid.meanRadius,

      camMoving: () => camMoving,
      cameraPos: camera.position,
      edgesPos:  camera.edgesPos,

      lonLatToScreenXY: camera.lonLatToScreenXY,

      cursorPos: cursor3d.cursorLonLat,
      isOnScene: cursor3d.isOnScene,
      cursorChanged: () => cursorChanged,
      wasTapped: cursor3d.wasTapped,

      update,
    };

    function update(time) {
      // Input time is a primitive floating point value representing the 
      // time this function was called, in seconds

      // Check for changes in display size
      let resized = view.changed();

      // Update camera dynamics
      camMoving = camera.update(time, resized, cursor3d);

      // Update cursor positions, if necessary
      cursorChanged = cursor2d.hasChanged() || camMoving || cursor3d.wasTapped();
      if (cursorChanged) cursor3d.update(cursor2d, camera);

      return camMoving;
    }
  }

  const map50mURL = "https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json";
  const map110mURL = "https://cdn.jsdelivr.net/npm/world-atlas@1/world/110m.json";

  const center = [-95.3656049, 29.7537002]; // Longitude, latitude (degrees)
  const altitude = 11000;
  const fieldOfView = 25.0;
  const degrees$3 = 180 / Math.PI;

  function main() {
    const globeDiv = document.getElementById("globe");

    const canvas = document.getElementById("globeCanvas");
    resizeCanvasToDisplaySize(canvas);
    var numPixelsX = canvas.clientWidth;
    var numPixelsY = canvas.clientHeight;
    const context = canvas.getContext("2d");
    // Save default styles
    context.save();

    const ball = init(globeDiv, center, altitude);

    const projection = geoSatellite()
      .translate([numPixelsX / 2, numPixelsY / 2])
      .precision(0.1);
   
    const path = index(projection, context);

    const graticuleMinor = graticule().step([5,5])();
    const graticuleMajor = graticule().step([15,15])();
    const horizon = {type: "Sphere"};

    // Get map data, start animation when ready
    var land110m, land50m, requestID, hiRes = false;
    var ready110m = fetch(map110mURL)
      .then( response => response.json() )
      .then( world => land110m = feature(world, world.objects.land) );
    var ready50m = fetch(map50mURL)
      .then( response => response.json() )
      .then( world => land50m = feature(world, world.objects.land) );

    Promise.all([ready110m, ready50m]).then(startAnimation);
   
    function startAnimation() {
      drawHiRes();
      requestID = requestAnimationFrame(animate);
    }

    function animate(time) {
      time *= 0.001; // Convert milliseconds to seconds
      let moving = ball.update(time);

      // Check for changes in display sizes
      let resized = resizeCanvasToDisplaySize(canvas);
      if (resized) {
        numPixelsX = canvas.clientWidth;
        numPixelsY = canvas.clientHeight;
        projection.translate([numPixelsX / 2, numPixelsY / 2]);
      }

      if (moving) {         // Draw low-res globe
        hiRes = false;
        drawLoRes();
      } else if (!hiRes) {  // Motion stopped. Draw hi-res globe
        drawHiRes();
        hiRes = true;
      }

      requestID = requestAnimationFrame(animate);
    }

    function drawHiRes() {
      renderPrep();
      drawLand(land50m);
      drawGraticule(graticuleMinor, 0.4);
      drawGraticule(graticuleMajor, 0.8);
      drawHorizon();
    }

    function drawLoRes() {
      renderPrep();
      drawLand(land110m);
      drawGraticule(graticuleMajor, 0.4);
      drawHorizon();
    }

    function renderPrep() {
      context.restore();
      context.save();
      context.clearRect(0, 0, numPixelsX, numPixelsY);

      let lon = ball.cameraPos[0] * degrees$3;
      let lat = ball.cameraPos[1] * degrees$3;
      let alt = ball.cameraPos[2];
      let snyderP = 1 + alt / ball.radius();
      let visibleYextent = 2 * alt * Math.tan(0.5 * fieldOfView / degrees$3);
      let scale = ball.radius() * numPixelsY / visibleYextent;

      projection.scale(scale)
        .rotate([-lon, -lat, 0])
        .distance(snyderP)
        .clipAngle(Math.acos(1 / snyderP) * degrees$3);
    }

    function drawLand(land) {
      context.beginPath();
      path(land);
      context.fill();
    }

    function drawGraticule(graticule, alpha) {
      context.beginPath();
      path(graticule);
      context.strokeStyle = "#aaa";
      context.globalAlpha = alpha;
      context.stroke();
    }

    function drawHorizon() {
      context.beginPath();
      path(horizon);
      context.strokeStyle = "#000";
      //context.globalAlpha = 1;
      context.stroke();
    }
  }

  exports.main = main;

  return exports;

}({}));
